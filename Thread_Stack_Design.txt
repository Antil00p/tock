----------------------Tock Networking Stack Design Document--------------------

/* NOTE: This document is a work in progress */

This document describes the design of the Networking stack on Tock.

The design described in this document is based off of ideas contributed by 
Phil Levis, Amit Levy, Paul Crews, Hubert Teo, Mateo Garcia, Daniel Giffin, and
Hudson Ayers.

This document is split into several sections. These are as follows:

-- Table of Contents --
  1. Principles - Describes the main principles which the design should meet,
     along with some justification of why these principles matter. Ultimately,
     the design should follow from these principles.
  2. Stack Diagram - Graphically depicts the layout of the stack
  3. List of Traits - Describes the traits which will exist at each layer of the
     stack. For traits that may seem surprisingly complex, provide examples of
     specific messages that require this more complex trait as opposed to the
     more obvious, simpler trait that might be expected.
  4. Implementation Details - Describes how certain implementations of these
     traits will work, providing some examples with pseudocode or commented
     explanations of functionality
  5. Example Message Traverals - Shows how different example messages (thread or 
     otherwise) will traverse the stack
  6. Suggested File Naming Convention - Currently capsules associated with the
     networking stack are named by a variety of conventions. This section
     proposes a unifying convention.

********************************** Principles **********************************

1. Keep the simple case simple
   - Sending an IP packet via an established thread network should not 
     require a more complicated interface than send(destination, packet)
   - If functionality were added to allow for the transmission of IP packets over
     the BLE interface, this IP send function should not have to deal with any
     options or MessageInfo structs that include 802.15.4 information.
   - This principle reflects a desire to limit the complexity of thread/the
     tock networking stack to the capsules that implement the stack. This 
     prevents the burden of this complexity from being passed up to whatever
     applications use Thread

2. Layering is separate from encapsulation
   - Libraries that handle encapsulation should not be contained within any
     specific layering construct. For example, If the thread control unit wants
     to encapsulate a UDP payload inside of a UDP packet inside of an IP packet,
     it should be able to do so using encapsulation libraries and get the 
     resulting IP packet without having to pass through all of the protocol layers
   - Accordingly, implementations of layers can take advantage of these 
     encapsulation libraries, but are not required to.

3. Dataplane traits are Thread-independent
   - For example, the IP trait should not make any assumption that send() 
     will be called for a message that will be passed down to the 15.4 layer, in
     case this IP trait is used on top of an implementation that passes IP
     packets down to be sent over a BLE link layer. Accordingly the IP trait
     can not expose any arguments regarding 802.15.4 security parameters.
   - Even for instances where the only implementation of a trait in the near
     future will be a Thread-based implementation, the traits should not
     require anything that limit such a trait to Thread-based implementations

4. Transmission and reception APIs are decoupled
   - This allows for instances where Receive and send_done callbacks should
     be delivered to different clients (ex: Server listening on all addresses
     but also sending messages from specific addresses)
   - Prevents send path from having to navigate the added complexity required
     for thread to determine whether to forward received messages up the stack

******************************** Stack Diagram ********************************

IPv6 over BLE:      Non-Thread 15.4:   Thread Stack:                                       Encapsulation Libraries
+-------------------+-------------------+----------------------------+
|                         Application                                |-------------------\
----------------------------------------+-------------+---+----------+                    \
|TCP Send| UDP Send |TCP Send| UDP Send |  | TCP Send |   | UDP Send |--\                  v
+--------+----------+--------+----------+  +----------+   +----------+   \               +------------+  +------------+
|     IP Send       |     IP Send       |  |         IP Send         |    \      ----->  | UDP Packet |  | TCP Packet | 
|                   |                   |  +-------------------------+     \    /        +------------+  +------------+ 
|                   |                   |                            |      \  /         +-----------+
|                   |                   |                            |       -+------->  | IP Packet |
|                   |                   |       THREAD               |       /           +-----------+
| IP Send calls eth | IP Send calls 15.4|                   <--------|------>            +-------------------------+
| 6lowpan libs with | 6lowpan libs with |                            |       \ ------->  | 6lowpan compress_Packet |
| default values    | default values    |                            |        \          +-------------------------+
|                   |                   |                            |         \         +-------------------------+
|                   |                   +                +-----------|          ------>  | 6lowpan fragment_Packet |             
|                   |                   |                | 15.4 Send |                   +-------------------------+
|-------------------|-------------------+----------------------------+
|     ethernet      |          IEEE 802.15.4 Link Layer              |
+-------------------+------------------------------------------------+

Notes on the stack:
- IP messages sent via Thread networks are sent through Thread using an IP Send
  method that exposes only the parameters specified in the IP_Send trait.
  Other parameters of the message (6lowpan decisions, link layer parameters, 
  many IP header options) are decided by Thread. 
- The stack provides an interface for the application layer to send
  raw IPv6 packets over Thread.
- Messages generated by the Thread control plane (MLE messages etc.) are 
  formatted using calls to the encapsulation libraries and then delivered to the
  802.15.4 layer using the 15.4 send function
- This stack design allows Thread to control header elements from transport down
  to link layer, and to set link layer security parameters and more as required
  for certain packers
- The application can either directly send IP messages using the IP Send
  implementation exposed by the Thread stack or it can use the UDP Send
  and TCP send implementation exposed by the Thread stack. If the application
  uses the TCP or UDP send implementations it must use the transport packet library
  to insert its payload inside a packet and set certain header fields.
  The transport send method uses the IP Packet library to set certain
  IP fields before handing the packet off to thread. Thread then sets other 
  parameters at other layers as needed before sending the packet off via the
  15.4 send function implemented for Thread. 
- This stack does not demonstrate a full set of functionality we are planning to
  implement now. Rather it demonstrates how this setup allows for multiple 
  implementations of each layer based off of traits and libraries such that a 
  flexible network stack can be configured, rather than creating a network 
  stack designed such that applications can only use thread.

******************************** List of Traits ********************************

This section describes a number of traits which must be implemented by any 
network stack. It is expected that multiple implemenations of some of these
traits may exist to allow for Tock to support more than just Thread networking.

These traits are organized by the network layer they would typically be
associated with.

======== Transport Layer ========

//TODO: TCP, once UDP agreed upon.

---
HELP: We discussed replacing calls to 'buf: &'static mut [u8]' with calls
to specific packet types (e.g., udp_packet: UDPPacket). I am not exactly sure
how this would work:

  1) Would UDPPacket the type refer to any object that implements the UDPPacket
  trait? Thus, should anything that implements the UDPPacket trait be a struct
  defined something like this:


    struct UDPPacket_ex {
      pub buf: &'static mut [u8];
    }

    struct UDPPacket_ex impl UDPPacket {
      ...
    }

  2) If my assumption in 1) is correct, is this really useful? I suppose that
  different implementation of UDPPacket could be structs with additional fields
  as required on an implementation by implementation basis..?
---

struct UDPHeader {
    pub src_port: u16;
    pub dst_port: u16;
    pub len: u16;
    pub cksum: u16;
}

struct UDPSocket_ex { /* Example UDP socket implementation */
    pub src_ip: IPAddr;
    pub src_port: u16;
    pub udp_sender: UDPSend;
}

trait UDPSocket {
    fn bind(src_ip: IPAddr, src_port: u16) -> ReturnCode; /* Return success */
    fn setSender(udp_sender: UDPSend) -> ReturnCode; /* Return success */
    fn newSender() -> UDPSend; /* Creates new UDPSend object */
}

trait UDPPacket {
    fn clear(); //Sets fields to appropriate defaults    
    fn getOffset() -> usize; //Always returns 8

    fn setDestPort(buf: &'static mut [u8], port: u16); 
    fn setSrcPort(buf: &'static mut [u8], port: u16);
    fn setLen(buf: &'static mut [u8], len: u16);
    fn setCksum(buf: &'static mut [u8], cksum: u16);
    fn getDestPort(buf: &'static [u8]) -> u16;
    fn getSrcPort(buf: &'static [u8]) -> u16;
    fn getLen(buf: &'static [u8]) -> u16;
    fn getCksum(buf: &'static [u8]) -> u16;

    fn setPayload(udp_packet: &'static mut[u8], payload: &'static mut[u8];
    //HELP: Perhaps it should instead be expected that users use the getOffset()
    //function to index into the buffer then set the payload themselves?

    /* Note that no UDP cksum function is required here. It is my belief that
       it makes more sense to require the IP layer implement a function to calculate
       the UDP cksum, as the IP layer is what should have access to all of the fields
       neccessary to construct the IPv6 Pseudoheader. */
}

trait UDPSend {
    fn send(dest: IP6Addr, udp_packet: &'static mut [u8]); // dest rqrd
    fn send_done(buf: &'static mut [u8], result: ReturnCode);
}

Notes on this UDP implementation:
  - Want to require a socket be used to call UDPSend at the application level
  - May not want this requirement within thread, so allow thread to directly
    call UDPSend

======== Network Layer ========

pub struct IP6Header {
    pub version_class_flow: [u8; 4],
    pub payload_len: u16,
    pub next_header: u8,
    pub hop_limit: u8,
    pub src_addr: IPAddr,
    pub dst_addr: IPAddr,
}

trait IP6Packet {
    fn reset(); //Sets fields to appropriate defaults
    fn getOffset() -> usize; //Always returns 40 until we add options support
    
    // Remaining functions are just getters and setters for the header fields
    fn setTF(buf: &'static mut [u8], TF);
    fn setFlowLabel(buf: &'static mut [u8], flow_label);
    fn setLen(buf: &'static mut [u8], u16);
    fn setProtocol(buf: &'static mut [u8], proto);
    fn setDestAddr(buf: &'static mut [u8], IPaddr);
    fn setSrcAddr(buf: &'static mut [u8], IPaddr);
    fn getTF(buf: &'static [u8]) -> TF;
    fn getFlowLabel(buf: &'static [u8])-> flow_label;
    fn getLen(buf: &'static [u8]) -> u16;
    fn getProtocol(buf: &'static [u8]) -> u8;
    fn getDestAddr(buf: &'static [u8]) -> IPAddr;
    fn getSrcAddr(buf: &'static [u8]) -> IPAddr;

    fn calcAndSetUDPcksum(buf: &'static [u8]) -> u16; //Assumes it has been
    // passed a valid IP packet, checks if it contains a UDP packet. If so, it
    // calculates the UDP cksum using the available IP and UDP fields and returns it.
}

trait IP6Send {
    fn sendTo(dest: IP6Addr, ip6_packet: &'static mut [u8]); //Convenience fn, sets dest addr, sends
    fn send(ip6_packet: &'static mut [u8]); //Length can be determined from IP6Packet
    fn send_done(buf: &'static mut [u8], result: ReturnCode);
}

======== 6lowpan Layer ========

/* NOTE: At the initial meeting where we planned out the creation of this
document, Phil suggested that we should create a 6lowpan layer with a single
trait (interface) for which the function would be implemented differently
depending on whether 15.4 6lowpan was being used or BLE 6lowpan etc. For now,
there are a number of things that would make such an interface difficult. For
instance, different return types (15.4 fragments or BLE fragments?), and
different parameters for compression (15.4 6lowpan requires source/dest MAC
addresses, not sure whether BLE uses BT hardware addresses the same way). */

pub struct Context { //Required for compression traits
    pub prefix: [u8; 16],
    pub prefix_len: u8,
    pub id: u8,
    pub compress: bool,
}

trait 6lowpanFragment {
    //TODO: Paul

    // For now: a guess at the functions such a library might require


    /* This function would have to be called in a loop, passing the same frag
       state and ip6 packet each time until the function inicates it is finished.
       Each iteration of the function would return the next fragment to be sent. This
       fragment could then be passed down to the link layer. */
    pub fn fragment(frag_state: FrageState, //some frag_state struct must exist
                    ip6_packet: &'static mut [u8], //Length can be extracted
                    ) -> Result<ReturnCode, &'static mut [u8];
}

pub trait ContextStore {
    fn get_context_from_addr(&self, ip_addr: IPAddr) -> Option<Context>;
    fn get_context_from_id(&self, ctx_id: u8) -> Option<Context>;
    fn get_context_0(&self) -> Context;
    fn get_context_from_prefix(&self, prefix: &[u8], prefix_len: u8) -> Option<Context>;
}

trait 6lowpanCompress {

    /* This function takes in an ipv6 packet and mac addresses and returns the
       compressed header. It is written as a recursive function and requires a
       context store. This is unchanged from the current library
       implementation except that now this will be a trait.
       Note that this function requires link layer MAC Addresses bc these are
       used in computing compressed source/dest IP addresses */

    fn compress(ctx_store: &ContextStore, 
                ip6_datagram: &[u8], 
                src_mac_addr,
                dst_mac_addr, 
                mut buf: &mut [u8]) -> Result<(usize, usize));
}


======== Link Layer ========

// Note: For now, this description does not provide details of the BLE stack

// The below functions merely describe the already implemented interface for
// IEEE 802.15.4 link layer. The stack design that this document
// details likely requires virtualization of this interface. This could be
// implemented via a method similar to the one that currently exists in 
// virtual_mac.rs but I beleive that some changes will be needed so that 
// file is current with our other link layer files.

pub trait Mac<'a> {
    /// Sets the transmission client of this MAC device
    fn set_transmit_client(&self, client: &'a TxClient);
    /// Sets the receive client of this MAC device
    fn set_receive_client(&self, client: &'a RxClient);

    /// The short 16-bit address of the MAC device
    fn get_address(&self) -> u16;
    /// The long 64-bit address (EUI-64) of the MAC device
    fn get_address_long(&self) -> [u8; 8];
    /// The 16-bit PAN ID of the MAC device
    fn get_pan(&self) -> u16;
    /// The 802.15.4 channel ID of the MAC device
    fn get_channel(&self) -> u8;
    /// The transmission power of the MAC device, in dBm
    fn get_tx_power(&self) -> i8;

    /// Set the short 16-bit address of the MAC device
    fn set_address(&self, addr: u16);
    /// Set the long 64-bit address (EUI-64) of the MAC device
    fn set_address_long(&self, addr: [u8; 8]);
    /// Set the 16-bit PAN ID of the MAC device
    fn set_pan(&self, id: u16);
    /// Set the 802.15.4 channel of the MAC device. `channel` should be a valid
    /// channel `11 <= channel <= 26`, otherwise EINVAL will be returned
    fn set_channel(&self, chan: u8) -> ReturnCode;
    /// Set the transmission power of the MAC device, in dBm. `power` should
    /// satisfy `-17 <= power <= 4`, otherwise EINVAL will be returned
    fn set_tx_power(&self, power: i8) -> ReturnCode;

    /// This method must be called after one or more calls to `set_*`. If
    /// `set_*` is called without calling `config_commit`, there is no guarantee
    /// that the underlying hardware configuration (addresses, pan ID) is in
    /// line with this MAC device implementation.
    fn config_commit(&self);

    /// Returns if the MAC device is currently on.
    fn is_on(&self) -> bool;

    /// Prepares a mutable buffer slice as an 802.15.4 frame by writing the appropriate
    /// header bytes into the buffer. This needs to be done before adding the
    /// payload because the length of the header is not fixed.
    ///
    /// - `buf`: The mutable buffer slice to use
    /// - `dst_pan`: The destination PAN ID
    /// - `dst_addr`: The destination MAC address
    /// - `src_pan`: The source PAN ID
    /// - `src_addr`: The source MAC address
    /// - `security_needed`: Whether or not this frame should be secured. This
    /// needs to be specified beforehand so that the auxiliary security header
    /// can be pre-inserted.
    ///
    /// Returns either a Frame that is ready to have payload appended to it, or
    /// the mutable buffer if the frame cannot be prepared for any reason
    fn prepare_data_frame(&self,
                          buf: &'static mut [u8],
                          dst_pan: PanID,
                          dst_addr: MacAddress,
                          src_pan: PanID,
                          src_addr: MacAddress,
                          security_needed: Option<(SecurityLevel, KeyId)>)
                          -> Result<Frame, &'static mut [u8]>;

    /// Transmits a frame that has been prepared by the above process. If the
    /// transmission process fails, the buffer inside the frame is returned so
    /// that it can be re-used.
    fn transmit(&self, frame: Frame) -> (ReturnCode, Option<&'static mut [u8]>);
}

/// Trait to be implemented by any user of the IEEE 802.15.4 device that
/// transmits frames. Contains a callback through which the static mutable
/// reference to the frame buffer is returned to the client.
pub trait TxClient {
    /// When transmission is complete or fails, return the buffer used for
    /// transmission to the client. `result` indicates whether or not
    /// the transmission was successful.
    ///
    /// - `spi_buf`: The buffer used to contain the transmitted frame is
    /// returned to the client here.
    /// - `acked`: Whether the transmission was acknowledged.
    /// - `result`: This is `ReturnCode::SUCCESS` if the frame was transmitted,
    /// otherwise an error occured in the transmission pipeline.
    fn send_done(&self, spi_buf: &'static mut [u8], acked: bool, result: ReturnCode);
}

// The below code is modified from virtual_mac.rs and provides insight into
// how virtualization of the mac layer might work


pub struct MacUser<'a> {
    mux: &'a MuxMac<'a>,
    operation: MapCell<Op>,
    next: ListLink<'a, MacUser<'a>>,
    tx_client: Cell<Option<&'a mac::TxClient>>,
}

trait MacUserTrait { //a MAC user would implement this and the mac trait
// Alternatively, this send_done function could just be added to the mac trait
// I did not show that here so that the above mac trait would be unchanged 
// from the current implementation.
    send_done(spi_buf: &'static mut [u8], acked: bool, result: ReturnCode);
    
}


**************************** Implementation Details ****************************
//TODO: This section needs a lot of work
//TODO: Show an entire psuedocode example implementation for a message
// traversing through Thread

One Example Implementation of IP6Send:

/* Implementation of IP6Send Specifically for sending MLE messages. This
implementation is incomplete and not entirely syntatically correct. However it
is useful in that it provides insight into the benefit of having IP6Send
merely be implemented as a trait instead of a layer. This function assumes
that the buffer passed in contains an already formatted IP message. (A
previous function would have been used to create the IP Header and place a UDP 
message with an MLE payload inside of it). This message then uses the
appropriate 6lowpan trait implementation to compress/fragment this IP message,
then sets the 15_4 link layer headers and settings as required. Accordingly
this function reveals how an implementation of IP6Send could give control to
Thread at the IP layer, 6lowpan layer, and 15.4 layer */

impl IP6Send for ThreadMLEIP6Send{
    fn sendTo(&self, dest: IP6Addr, buf) {
        setDestAddr(buf, dest);
        self.send(buf);
    }
    
    fn send(&self, buf) {
        calcAndSetUDPChecksum(buf); //If packet is UDP, this sets the cksum
        ctx_store = sixlowpan_comp::ContextStore::new();
        compressed_packet [u8] = 15_4_6lowpan_compress(ctx_store, buf,
                                                       src_mac, dst_mac);
        fragState = sixlowpan_frag::fragState::new(buf, len);
        while(fragState != Done) {
            let fragToSend: 15_4_frag_buf = 15_4_6lowpan_frag(buf, len, fragState);
            fragToSend.setSrcPANID(threadPANID);
            if(compressed_packet.is_disc_request()) {
                fragToSend.setSrcMAC(MAC::generate_random());
            }
            // etc.... (Thread decision making)
            let security = securityType::MLESecurity;
            15_4_link_layer_send(fragToSend, security, len); 
        }
    }
}

/* Implementation of IP6Send for an application sitting on top of thread which
simply wants to send an IP message through thread. For such an instance the
user does not need to worry about setting parameters below the IP layer, as
thread handles this. This function reflects thread making those decisions in
such a scenario */
impl IP6Send for IP6SendThroughThread {
    fn sendTo(&self, dest: IP6Addr, buf, len) {
        setDestAddr(buf, dest);
        self.send(buf, len);
    }

    fn send(&self, buf, len) {
        calcAndSetUDPChecksum(buf); //If packet is UDP, this sets the cksum
        compressed_packet [u8] = 15_4_6lowpan_compress(buf, len);
        fragState = new fragState(buf, len);
        while(fragState != Done) {
            let fragToSend: 15_4_frag_buf = 15_4_6lowpan_frag(buf, len, fragState);
            fragToSend.setSrcPANID(threadPANID);
            fragToSend.setSrcMAC(getSrcMacFromSrcIPaddr(buf.getSrcIP);
            // etc....
            let security = securityType::LinkLayerSec;
            15_4_link_layer_send(fragToSend, security, len); 

        }
    }


}

/* Implementation of UDPSend for an application sitting on top of thread which
simply wants to send a UDP message through thread. This simply calls on the
appropriate implementation of IP6Send sitting beneath it. Recall that this
function assumes it is passed an already formatted UDP Packet. Also recall the
assumption that the IPSend function will calculate and set the UDP cksum. */

impl UDPSend for UDPSendThroughThread {
    fn send(&self, dest, buf) {

        /* First, library calls to format IP Packet */
        IPPacketForThread.setDstAddr(buf, dest);
        IPPacketForThread.setSrcAddr(buf, THREAD_GLOBAL_SRC_IP_CONST); /* this fn only
          called for globally destined packets sent over thread network */
        IPPacketForThread.setTF(0);
        IPPacketForThread.setHopLimit(64);
        IPPacketForThread.setProtocol(UDP_PROTO_CONST);
        IPPacketForThread.setLen(buf, ???); /*Will length be field of packet*/
        IPPacketForThread.setFlowLabel(buf, ???); /* How to determine FL? */
        /* Now, send the packet */
        IP6SendThroughThread.sendTo(dest, buf)
    }
}

The above imlementations are not meant to showcase accurate code, but rather
give an example as to how multiple implementations of a given trait can be
useful in the creation of a flexible network stack.


************************** Example Message Traversals **************************
TODO: Hubert


***************************** Suggested File Names *****************************
Currently capsules associated with the networking stack are named according to a
variety of conventions. This section proposes some changes.

'thread' directory should eventually contain any layers implemented with
specifically thread in mind - files such as ip_thread.rs, which would contain
implementations of the traits found in net::ip.rs. The tlv.rs file which
currently resides here should remain here as well. 

net::udp.rs - Should contain functions and traits associated with the generic UDP layer.
For instance, this file would include the UDPPacket and UDPSend traits, the
UDPHeader struct, and functions associated with calculating the UDP checksum.
This file should contain basic library implementations for the UDPPacket trait.

net::ip.rs - Should contain functions associated with the generic IP layer. For
instance, this file would include the IPPacket and IPSend traits, the IPHeader
struct, and any other functions which any IP implementation would have to
implement. This function would also provide documentation regarding how this
generic layer should be implemented. This file should contain basic library
implementations for the IPPacket Trait.

net::ip_utils.rs - The functions contained in the file currently named ip.rs
should be moved into a file named ip_utils.rs to better indicate the purpose
of this file.

net::sixlowpan_utils.rs - The function currently found at net::util.rs should
be renamed to sixlowpan_utils.rs to better reflect its purpose. Further, it
seems as though the functions/structs currently contained in
net::frag_utils.rs should simply be moved into this file as well.

net::sixlowpan_frag.rs - Contains functions and interfaces pertaining to the
sixlowpan fragmentation library. (What is currently called sixlowpan.rs)

net::sixlowpan_comp.rs - Contains functions and interfaces pertaining to the
sixlowpan compression library.

ieee802154_enc_dec.rs - Implements 15.4 header encoding and decoding.
Currently should found at net::ieee802154.rs - should be renamed and
moved within the greater ieee802154 directory in capsules. 

ieee802154 directory can be left as is.


Once the traits have been defined and placed in udp.rs/ip.rs etc. , the
various implementations of these traits should be defined in their own files,
such as udp_through_thread.rs (could contain the UDPSend trait implementations to
be used by applications sending UDP across an established thread network).
Another file could simultaneously exist called 'udp_no_thread.rs' which is
used for an implementation that allowed for sending through a stack which was
totally seperate from the thread stack. 


