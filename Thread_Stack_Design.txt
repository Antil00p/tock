----------------------Tock Networking Stack Design Document--------------------

/* NOTE: This document is a work in progress */

This document describes the design of the Networking stack on Tock.

The design described in this document is based off of ideas contributed by 
Phil Levis, Amit Levy, Paul Crews, Hubert Teo, Mateo Garcia, Daniel Giffin, and
Hudson Ayers.

This document is split into several sections. These are as follows:

-- Table of Contents --
  1. Principles - Describes the main principles which the design should meet,
     along with some justification of why these principles matter. Ultimately,
     the design should follow from these principles.
  2. Stack Diagram - Graphically depicts the layout of the stack
  3. List of Traits - Describes the traits which will exist at each layer of the
     stack. For traits that may seem surprisingly complex, provide examples of
     specific messages that require this more complex trait as opposed to the
     more obvious, simpler trait that might be expected.
  4. Implementation Details - Describes how certain implementations of these
     traits will work, providing some examples with pseudocode or commented
     explanations of functionality
  5. Example Message Traverals - Shows how different example messages (Thread or 
     otherwise) will traverse the stack
  6. Suggested File Naming Convention - Currently capsules associated with the
     networking stack are named by a variety of conventions. This section
     proposes a unifying convention.

********************************** Principles **********************************

1. Keep the simple case simple
   - Sending an IP packet via an established Thread network should not 
     require a more complicated interface than send(destination, packet)
   - If functionality were added to allow for the transmission of IP packets over
     the BLE interface, this IP send function should not have to deal with any
     options or MessageInfo structs that include 802.15.4 information.
   - This principle reflects a desire to limit the complexity of Thread/the
     tock networking stack to the capsules that implement the stack. This 
     prevents the burden of this complexity from being passed up to whatever
     applications use Thread

2. Layering is separate from encapsulation
   - Libraries that handle encapsulation should not be contained within any
     specific layering construct. For example, If the Thread control unit wants
     to encapsulate a UDP payload inside of a UDP packet inside of an IP packet,
     it should be able to do so using encapsulation libraries and get the 
     resulting IP packet without having to pass through all of the protocol layers
   - Accordingly, implementations of layers can take advantage of these 
     encapsulation libraries, but are not required to.

3. Dataplane traits are Thread-independent
   - For example, the IP trait should not make any assumption that send() 
     will be called for a message that will be passed down to the 15.4 layer, in
     case this IP trait is used on top of an implementation that passes IP
     packets down to be sent over a BLE link layer. Accordingly the IP trait
     can not expose any arguments regarding 802.15.4 security parameters.
   - Even for instances where the only implementation of a trait in the near
     future will be a Thread-based implementation, the traits should not
     require anything that limit such a trait to Thread-based implementations

4. Transmission and reception APIs are decoupled
   - This allows for instances where Receive and send_done callbacks should
     be delivered to different clients (ex: Server listening on all addresses
     but also sending messages from specific addresses)
   - Prevents send path from having to navigate the added complexity required
     for Thread to determine whether to forward received messages up the stack

******************************** Stack Diagram ********************************

IPv6 over ethernet:      Non-Thread 15.4:   Thread Stack:                                       Encapsulation Libraries
+-------------------+-------------------+----------------------------+
|                         Application                                |-------------------\
----------------------------------------+-------------+---+----------+                    \
|TCP Send| UDP Send |TCP Send| UDP Send |  | TCP Send |   | UDP Send |--\                  v
+--------+----------+--------+----------+  +----------+   +----------+   \               +------------+  +------------+
|     IP Send       |     IP Send       |  |         IP Send         |    \      ----->  | UDP Packet |  | TCP Packet | 
|                   |                   |  +-------------------------+     \    /        +------------+  +------------+ 
|                   |                   |                            |      \  /         +-----------+
|                   |                   |                            |       -+------->  | IP Packet |
|                   |                   |       THREAD               |       /           +-----------+
| IP Send calls eth | IP Send calls 15.4|                   <--------|------>            +-------------------------+
| 6lowpan libs with | 6lowpan libs with |                            |       \ ------->  | 6lowpan compress_Packet |
| default values    | default values    |                            |        \          +-------------------------+
|                   |                   |                            |         \         +-------------------------+
|                   |                   +                +-----------|          ------>  | 6lowpan fragment_Packet |             
|                   |                   |                | 15.4 Send |                   +-------------------------+
|-------------------|-------------------+----------------------------+
|     ethernet      |          IEEE 802.15.4 Link Layer              |
+-------------------+------------------------------------------------+

Notes on the stack:
- IP messages sent via Thread networks are sent through Thread using an IP Send
  method that exposes only the parameters specified in the IP_Send trait.
  Other parameters of the message (6lowpan decisions, link layer parameters, 
  many IP header options) are decided by Thread. 
- The stack provides an interface for the application layer to send
  raw IPv6 packets over Thread.
- Messages generated by the Thread control plane (MLE messages etc.) are 
  formatted using calls to the encapsulation libraries and then delivered to the
  802.15.4 layer using the 15.4 send function
- This stack design allows Thread to control header elements from transport down
  to link layer, and to set link layer security parameters and more as required
  for certain packers
- The application can either directly send IP messages using the IP Send
  implementation exposed by the Thread stack or it can use the UDP Send
  and TCP send implementation exposed by the Thread stack. If the application
  uses the TCP or UDP send implementations it must use the transport packet library
  to insert its payload inside a packet and set certain header fields.
  The transport send method uses the IP Packet library to set certain
  IP fields before handing the packet off to Thread. Thread then sets other 
  parameters at other layers as needed before sending the packet off via the
  15.4 send function implemented for Thread. 
- This stack does not demonstrate a full set of functionality we are planning to
  implement now. Rather it demonstrates how this setup allows for multiple 
  implementations of each layer based off of traits and libraries such that a 
  flexible network stack can be configured, rather than creating a network 
  stack designed such that applications can only use Thread.

******************************** List of Traits ********************************

This section describes a number of traits which must be implemented by any 
network stack. It is expected that multiple implemenations of some of these
traits may exist to allow for Tock to support more than just Thread networking.

Before discussing these traits - a note on buffers:

    Up until now, the tock networking stack has primarily passed around references 
    to 'static mut [u8] to pass packets along the stack. This is not ideal from a
    standpoint of wanting
    to be able to prevent as many errors as possible at compile time. Instead,
    this code will pass 'typed' buffers up and down the stack. There are a number
    of packet library traits defined below (e.g. IPPacket, UDPPacket, etc.). Each
    trait will be implemented by a struct that will contain at least one field -
    a [u8] buffer with lifetime 'a. This design allows for all buffers passed to
    be passed as type 'UDPPacket', 'IPPacket', etc. An added advantage of this
    design is that each buffer can easily be operated on using the library
    functions associated with this buffer type. 

    One result of this design decision is that it requires each lower layer
    'send' call to implement multiple send() functions, one for each type of
    buffer that could be passed to it. For example, in order to have a fully
    functioning IP layer, there would need to be an implementation of the
    send() function for each transport protocol. Ex:

    trait IPSend() {
        fn send(&'static mut UDPPacket);
        fn send(&'static mut TCPPacket);
        fn send(&'static mut ICMPPacket);
        fn send(&'static mut [u8];
    }

    This example gives insight into how typed buffers complicate the traits
    required to allow for typed buffer checking, and hopefullys make the 
    use of buffers in the trait descriptions that follow more clear.

The traits below are organized by the network layer they would typically be
associated with.

/* IDEA: Have enum with a reference to traits */
// Have 6lowpan init take IP packet
// 6lowpan prepare_packet does not take it in bc it is already stored in a
// takecell in the 6lowpan object
//BUT: When you get a send_done callback youre continuing to transport a
packet but you cant tell what pkt youre continuing to transmit
// this doesnt work as well for tcp and icmp but there are ways around that i
think
// this is okay bc there are 102 bytes of payload

/* TODO: Send email to mailing list describing 4 options for moving forward:

1. Dont used typed buffers
2. Use enum w/ references (try first!)
3. Use what I have implemented in interfaces.rs
4. Have a TransPacket trait that all other packets implement. This trait has
functions for every possible transport packet, but the functions only work if
called on the appropriate implementing struct.

These are the only options bc of the fundamental issue that enums cant hold
traits, and the IPPacket struct needs to be able to hold a packet that is any
type of transport layer packet


======== Transport Layer ========

//TODO: TCP, ICMP once UDP agreed upon.

struct UDPHeader {
    pub src_port: u16;
    pub dst_port: u16;
    pub len: u16;
    pub cksum: u16;
}

struct UDPSocket_ex { /* Example UDP socket implementation */
    pub src_ip: IPAddr;
    pub src_port: u16;
}

trait UDPSocket:UDPSend {
    fn bind(&self, src_ip: IPAddr, src_port: u16) -> ReturnCode;
    fn send(&self, dest: IP6Addr, udp_packet: &'static UDPPacket) ->ReturnCode;
    fn send_done(&self, udp_packet: &'static UDPPacket, result: ReturnCode);
}

struct UDPPacket_ex { /* Example UDP Packet struct */
    pub header: UDPHeader;
    pub payload: &'a [u8]; //Not mutable!
    pub len: u16; // length of payload
}

trait UDPPacket {
    fn reset(&self); //Sets fields to appropriate defaults    
    fn getOffset(&self) -> usize; //Always returns 8

    fn setDestPort(&self, port: u16); 
    fn setSrcPort(&self, port: u16);
    fn setLen(&self, len: u16);
    fn setCksum(&self, cksum: u16);
    fn getDestPort(&self) -> u16;
    fn getSrcPort(&self) -> u16;
    fn getLen(&self) -> u16;
    fn getCksum(&self) -> u16;

    fn setPayload<'a>(&self, payload: &'a [u8];

    /* Note that no UDP cksum function is required here. It is my belief that
       it makes more sense to require the IP layer implement a function to calculate
       the UDP cksum, as the IP layer is what should have access to all of the fields
       neccessary to construct the IPv6 Pseudoheader. Further, openThread uses
       this same approach*/
}

trait UDPSend {
    fn send(dest: IP6Addr, udp_packet: &'static mut UDPPacket); // dest rqrd
    fn send_done(buf: &'static mut UDPPacket, result: ReturnCode);
}

Notes on this UDP implementation:
  - Want to require a socket be used to call UDPSend at the application level
  - May not want this requirement within Thread, so allow Thread to directly
    call UDPSend (this is the reason for seperation between UDPSocket and
    UDPSend traits)

======== Network Layer ========

pub struct IP6Header {
    pub version_class_flow: [u8; 4],
    pub payload_len: u16,
    pub next_header: u8,
    pub hop_limit: u8,
    pub src_addr: IPAddr,
    pub dst_addr: IPAddr,
}


pub enum TransportPacket { //doesnt work, cant have traits as fields of enum
    UDP(UDPPacket),
    TCP(TCPPacket), /* NOTE: TCP,ICMP,RawIP traits not yet detailed in this
                     * document, but follow logically from UDPPacket trait. */
    ICMP(ICMPPacket),
    Raw(RawIPPacket),
}


pub struct IP6Packet_ex {
    pub header: IP6Header;
    pub payload: TransportPacket; //yeah this doesnt work
}

/* Idea: have IP6_packet_udp_payload, IP6_packet_tcp_payload ... structs. This
   would work if the IP6packet trait had fns like returnUDPpayloadifUDP() ->
   UDPPacket etc. */

trait IP6Packet {
    fn new(payload: TransportPacket) -> IP6Packet;
    fn reset(&self); //Sets fields to appropriate defaults
    fn getOffset(&self) -> usize; //Always returns 40 until we add options support
    
    // Remaining functions are just getters and setters for the header fields
    fn setTF(&self, TF);
    fn setFlowLabel(&self, flow_label);
    fn setLen(&self, u16);
    fn setProtocol(&self, proto);
    fn setDestAddr(&self, IPaddr);
    fn setSrcAddr(&self, IPaddr);
    fn getTF(&self) -> TF;
    fn getFlowLabel(&self)-> flow_label;
    fn getLen(&self) -> u16;
    fn getProtocol(&self) -> u8;
    fn getDestAddr(&self) -> IPAddr;
    fn getSrcAddr(&self) -> IPAddr;

    fn calcAndSetUDPcksum(&self) -> u16; //Looks at internal buffer assuming
    // it contains a valid IP packet, checks if it contains a UDP packet. If so, it
    // calculates the UDP cksum using the IP and UDP fields and returns it.
}

trait IP6Send {
    fn sendTo(dest: IP6Addr, ip6_packet: &'static mut IP6Packet); //Convenience fn, sets dest addr, sends
    fn send(ip6_packet: &'static mut IP6Packet); //Length can be determined from IP6Packet
    fn send_done(ip6_packet: &'static mut IP6Packet, result: ReturnCode);
}

======== 6lowpan Layer ========

/* NOTE: At the initial meeting where we planned out the creation of this
document, Phil suggested that we should create a 6lowpan layer with a single
trait (interface) for which the function would be implemented differently
depending on whether 15.4 6lowpan was being used or BLE 6lowpan etc. For now,
there are a number of things that would make such an interface difficult. For
instance, different return types (15.4 fragments or BLE fragments?), and
different parameters for compression (15.4 6lowpan requires source/dest MAC
addresses, not sure whether BLE uses BT hardware addresses the same way). */

pub struct Context { //Required for compression traits
    pub prefix: [u8; 16],
    pub prefix_len: u8,
    pub id: u8,
    pub compress: bool,
}

trait 6lowpanFragment {
    // TODO: Paul, please give feedback on if these interfaces are correct
    // For now, this is my best guess at how these should look


    /* This function would have to be called multiple times, passing the same frag
       state and ip6 packet each time until the function indicates it is finished.
       Each iteration of the function would return the next fragment to be sent. This
       fragment could then be passed down to the link layer. Notably, if this
       function is called, there is no reason to call the compression library,
       as the frag library calls the compression library internally.
       Accordingly, it is not possible to fragment without the compression
       library being called. This should be fine, as there are no realistic
       use cases which require this. Calling the compression library without
       fragmentation (as required by 6lowpan over BLE, for example) is
       possible */
    pub fn fragment(frag_state: FrageState, //some frag_state struct must exist
                    ip6_packet: &'a IP6Packet, //Length can be extracted
                    ) -> Result<ReturnCode, &'static mut [u8]>; // Returned buffer
                                                                // is the link layer frame.
}

pub trait ContextStore {
    fn get_context_from_addr(&self, ip_addr: IPAddr) -> Option<Context>;
    fn get_context_from_id(&self, ctx_id: u8) -> Option<Context>;
    fn get_context_0(&self) -> Context;
    fn get_context_from_prefix(&self, prefix: &[u8], prefix_len: u8) -> Option<Context>;
}

trait 6lowpanCompress {

    /* This function takes in an ipv6 packet and mac addresses and returns the
       compressed header. It is written as a recursive function and requires a
       context store. This is unchanged from the current library
       implementation except that now this will be a trait.
       Note that this function requires link layer MAC Addresses bc these are
       used in computing compressed source/dest IP addresses */

    fn compress(ctx_store: &ContextStore, 
                ip6_datagram: &'static IPPacket, 
                src_mac_addr,
                dst_mac_addr, 
                mut buf: &mut [u8]) -> Result<(usize, usize));
}


======== Link Layer ========

// Note: For now, this description does not provide details of the BLE stack

// The below functions merely describe the already implemented interface for
// IEEE 802.15.4 link layer. The stack design that this document
// details likely requires virtualization of this interface. This could be
// implemented via a method similar to the one that currently exists in 
// virtual_mac.rs but I beleive that some changes will be needed so that 
// file is current with our other link layer files.

pub trait Mac<'a> {
    /// Sets the transmission client of this MAC device
    fn set_transmit_client(&self, client: &'a TxClient);
    /// Sets the receive client of this MAC device
    fn set_receive_client(&self, client: &'a RxClient);

    /// The short 16-bit address of the MAC device
    fn get_address(&self) -> u16;
    /// The long 64-bit address (EUI-64) of the MAC device
    fn get_address_long(&self) -> [u8; 8];
    /// The 16-bit PAN ID of the MAC device
    fn get_pan(&self) -> u16;
    /// The 802.15.4 channel ID of the MAC device
    fn get_channel(&self) -> u8;
    /// The transmission power of the MAC device, in dBm
    fn get_tx_power(&self) -> i8;

    /// Set the short 16-bit address of the MAC device
    fn set_address(&self, addr: u16);
    /// Set the long 64-bit address (EUI-64) of the MAC device
    fn set_address_long(&self, addr: [u8; 8]);
    /// Set the 16-bit PAN ID of the MAC device
    fn set_pan(&self, id: u16);
    /// Set the 802.15.4 channel of the MAC device. `channel` should be a valid
    /// channel `11 <= channel <= 26`, otherwise EINVAL will be returned
    fn set_channel(&self, chan: u8) -> ReturnCode;
    /// Set the transmission power of the MAC device, in dBm. `power` should
    /// satisfy `-17 <= power <= 4`, otherwise EINVAL will be returned
    fn set_tx_power(&self, power: i8) -> ReturnCode;

    /// This method must be called after one or more calls to `set_*`. If
    /// `set_*` is called without calling `config_commit`, there is no guarantee
    /// that the underlying hardware configuration (addresses, pan ID) is in
    /// line with this MAC device implementation.
    fn config_commit(&self);

    /// Returns if the MAC device is currently on.
    fn is_on(&self) -> bool;

    /// Prepares a mutable buffer slice as an 802.15.4 frame by writing the appropriate
    /// header bytes into the buffer. This needs to be done before adding the
    /// payload because the length of the header is not fixed.
    ///
    /// - `buf`: The mutable buffer slice to use
    /// - `dst_pan`: The destination PAN ID
    /// - `dst_addr`: The destination MAC address
    /// - `src_pan`: The source PAN ID
    /// - `src_addr`: The source MAC address
    /// - `security_needed`: Whether or not this frame should be secured. This
    /// needs to be specified beforehand so that the auxiliary security header
    /// can be pre-inserted.
    ///
    /// Returns either a Frame that is ready to have payload appended to it, or
    /// the mutable buffer if the frame cannot be prepared for any reason
    fn prepare_data_frame(&self,
                          buf: &'static mut [u8],
                          dst_pan: PanID,
                          dst_addr: MacAddress,
                          src_pan: PanID,
                          src_addr: MacAddress,
                          security_needed: Option<(SecurityLevel, KeyId)>)
                          -> Result<Frame, &'static mut [u8]>;

    /// Transmits a frame that has been prepared by the above process. If the
    /// transmission process fails, the buffer inside the frame is returned so
    /// that it can be re-used.
    fn transmit(&self, frame: Frame) -> (ReturnCode, Option<&'static mut [u8]>);
}

/// Trait to be implemented by any user of the IEEE 802.15.4 device that
/// transmits frames. Contains a callback through which the static mutable
/// reference to the frame buffer is returned to the client.
pub trait TxClient {
    /// When transmission is complete or fails, return the buffer used for
    /// transmission to the client. `result` indicates whether or not
    /// the transmission was successful.
    ///
    /// - `spi_buf`: The buffer used to contain the transmitted frame is
    /// returned to the client here.
    /// - `acked`: Whether the transmission was acknowledged.
    /// - `result`: This is `ReturnCode::SUCCESS` if the frame was transmitted,
    /// otherwise an error occured in the transmission pipeline.
    fn send_done(&self, spi_buf: &'static mut [u8], acked: bool, result: ReturnCode);
}

// The below code is modified from virtual_mac.rs and provides insight into
// how virtualization of the mac layer might work

// This is one approach, but Phil suggest we probably want to go with the more
// generalize approach (using the virtualizer queue)
pub struct MacUser<'a> {
    mux: &'a MuxMac<'a>,
    operation: MapCell<Op>,
    next: ListLink<'a, MacUser<'a>>,
    tx_client: Cell<Option<&'a mac::TxClient>>,
}

trait MacUserTrait { //a MAC user would implement this and the mac trait
// Alternatively, this send_done function could just be added to the mac trait
// I did not show that here so that the above mac trait would be unchanged 
// from the current implementation.
    send_done(spi_buf: &'static mut [u8], acked: bool, result: ReturnCode);
    
}


**************************** Implementation Details ****************************
// TODO: This section needs a lot of work
// Ultimately, this section will include pseudocode examples of how differnet
// implementation of these traits should look for different Thread messages that
// might be sent, and for other messages (non-thread) that might be sent using
// this messaging stack.

One Example Implementation of IP6Send:

/* Implementation of IP6Send Specifically for sending MLE messages. This
implementation is incomplete and not entirely syntatically correct. However it
is useful in that it provides insight into the benefit of having IP6Send
merely be implemented as a trait instead of a layer. This function assumes
that the buffer passed in contains an already formatted IP message. (A
previous function would have been used to create the IP Header and place a UDP 
message with an MLE payload inside of it). This message then uses the
appropriate 6lowpan trait implementation to compress/fragment this IP message,
then sets the 15_4 link layer headers and settings as required. Accordingly
this function reveals how an implementation of IP6Send could give control to
Thread at the IP layer, 6lowpan layer, and 15.4 layer */

impl IP6Send for ThreadMLEIP6Send{
    fn sendTo(&self, dest: IP6Addr, ip6_packet: IP6Packet) {
        ip6_packet.setDestAddr(dest);
        self.send(ip6_packet);
    }
    
    fn send(&self, ip6_packet: IP6Packet) {
        ip6_packet.calcAndSetUDPChecksum(); //If packet is UDP, this sets the cksum
        ctx_store = sixlowpan_comp::ContextStore::new();
        fragState = sixlowpan_frag::fragState::new(ip6_packet);

        /* Note: the below loop should be replaced with repetitions on callbacks, but
        you get the idea - multiple calls to the frag library are required to
        send all of the link layer frames */

        while(fragState != Done) {
            let fragToSend: 15_4_frag_buf = 15_4_6lowpan_frag(&ip6_packet, fragState);
            fragToSend.setSrcPANID(threadPANID);
            if(ip6_packet.is_disc_request()) { // One example of a thread
                                               // decision that affects link layer parameters
                fragToSend.setSrcMAC(MAC::generate_random());
            }
            // etc.... (More Thread decision making)
            let security = securityType::MLESecurity;
            15_4_link_layer_send(fragToSend, security, len); 
        }
    }
}

/* Implementation of IP6Send for an application sitting on top of Thread which
simply wants to send an IP message through Thread. For such an instance the
user does not need to worry about setting parameters below the IP layer, as
Thread handles this. This function reflects Thread making those decisions in
such a scenario */
impl IP6Send for IP6SendThroughThread {
    fn sendTo(&self, dest: IP6Addr, ip6_packet: IP6Packet) {
        setDestAddr(ip6_packet, dest);
        self.send(ip6_packet);
    }

    fn send(&self, ip6_packet: IP6Packet) {
        ip6_packet.calcAndSetUDPChecksum(); //If packet is UDP, this sets the cksum
        fragState = new fragState(ip6_packet);
        while(fragState != Done) {
            let fragToSend: 15_4_frag_buf = 15_4_6lowpan_frag(&ip6_packet, fragState);
            fragToSend.setSrcPANID(threadPANID);
            fragToSend.setSrcMAC(getSrcMacFromSrcIPaddr(ip6_packet.getSrcIP));
            // etc....
            let security = securityType::LinkLayerSec;
            15_4_link_layer_send(fragToSend, security, len); 

        }
    }
}

/* Implementation of UDPSend for an application sitting on top of Thread which
simply wants to send a UDP message through Thread. This simply calls on the
appropriate implementation of IP6Send sitting beneath it. Recall that this
function assumes it is passed an already formatted UDP Packet. Also recall the
assumption that the IPSend function will calculate and set the UDP cksum. */

impl UDPSend for UDPSendThroughThread {
    fn send(&self, dest, udp_packet: UDPPacketForThread) {

        let trans_pkt = TransportPacket::UDP(udp_packet);

        ip6_packet = IPPacketForThread.new(trans_pkt);

        /* First, library calls to format IP Packet */
        ip6_packet.setDstAddr(dest);
        ip6_packet.setSrcAddr(THREAD_GLOBAL_SRC_IP_CONST); /* this fn only
          called for globally destined packets sent over Thread network */
        ip6_packet.setTF(0);
        ip6_packet.setHopLimit(64);
        ip6_packet.setProtocol(UDP_PROTO_CONST);
        ip6_packet.setLen(40 + trans_pkt.); /*Will length be field of packet*/
        ip6_packet.setFlowLabel(???); /* How to determine FL? */
        /* Now, send the packet */
        IP6SendThroughThread.sendTo(dest, ip6_packet);
    }
}

The above imlementations are not meant to showcase accurate code, but rather
give an example as to how multiple implementations of a given trait can be
useful in the creation of a flexible network stack.


************************** Example Message Traversals **************************
TODO: Hubert


***************************** Suggested File Names *****************************
Currently capsules associated with the networking stack are named according to a
variety of conventions. This section proposes some changes.

'Thread' directory should eventually contain any layers implemented with
specifically Thread in mind - files such as ip_thread.rs, which would contain
implementations of the traits found in net::ip.rs. The tlv.rs file which
currently resides here should remain here as well. 

net::udp.rs - Should contain functions and traits associated with the generic UDP layer.
For instance, this file would include the UDPPacket and UDPSend traits, the
UDPHeader struct, and functions associated with calculating the UDP checksum.
This file should contain basic library implementations for the UDPPacket trait.

net::ip.rs - Should contain functions associated with the generic IP layer. For
instance, this file would include the IPPacket and IPSend traits, the IPHeader
struct, and any other functions which any IP implementation would have to
implement. This function would also provide documentation regarding how this
generic layer should be implemented. This file should contain basic library
implementations for the IPPacket Trait.

net::ip_utils.rs - The functions contained in the file currently named ip.rs
should be moved into a file named ip_utils.rs to better indicate the purpose
of this file.

net::sixlowpan_utils.rs - The function currently found at net::util.rs should
be renamed to sixlowpan_utils.rs to better reflect its purpose. Further, it
seems as though the functions/structs currently contained in
net::frag_utils.rs should simply be moved into this file as well.

net::sixlowpan_frag.rs - Contains functions and interfaces pertaining to the
sixlowpan fragmentation library. (What is currently called sixlowpan.rs)

net::sixlowpan_comp.rs - Contains functions and interfaces pertaining to the
sixlowpan compression library.

ieee802154_enc_dec.rs - Implements 15.4 header encoding and decoding.
Currently should found at net::ieee802154.rs - should be renamed and
moved within the greater ieee802154 directory in capsules. 

ieee802154 directory can be left as is.


Once the traits have been defined and placed in udp.rs/ip.rs etc. , the
various implementations of these traits should be defined in their own files,
such as udp_through_thread.rs (could contain the UDPSend trait implementations to
be used by applications sending UDP across an established Thread network).
Another file could simultaneously exist called 'udp_no_thread.rs' which is
used for an implementation that allowed for sending through a stack which was
totally seperate from the Thread stack. 


