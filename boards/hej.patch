diff --git a/boards/nrf51dk/chip_layout.ld b/boards/nrf51dk/chip_layout.ld
index b623f5b2..de6f699e 100644
--- a/boards/nrf51dk/chip_layout.ld
+++ b/boards/nrf51dk/chip_layout.ld
@@ -3,6 +3,6 @@ ROM_LENGTH  = 128K;
 PROG_ORIGIN = 0x00020000;
 PROG_LENGTH = 128K;
 RAM_ORIGIN  = 0x20000000;
-RAM_LENGTH  = 16K;
+RAM_LENGTH  = 32K;
 
 MPU_MIN_ALIGN = 8;
diff --git a/chips/nrf51/src/radio.rs b/chips/nrf51/src/radio.rs
index 2127c399..86e436fc 100644
--- a/chips/nrf51/src/radio.rs
+++ b/chips/nrf51/src/radio.rs
@@ -16,6 +16,8 @@ use kernel;
 use kernel::ReturnCode;
 use nrf5x;
 use nrf5x::ble_advertising_hil::RadioChannel;
+use nrf5x::ble_advertising_driver::BLEAdvertisementType;
+use nrf5x::ble_advertising_driver::BLEPduType;
 use nrf5x::constants::TxPower;
 use peripheral_registers;
 
@@ -190,9 +192,12 @@ impl Radio {
             regs.address.set(0);
         }
 
+        //debug!("Regs state: {}, end = {}", regs.state.get(), regs.end.get());
+
         if regs.end.get() == 1 {
+            //debug!("End == 1");
             regs.end.set(0);
-            regs.disable.set(1);
+            //regs.disable.set(1);
 
             let result = if regs.crcstatus.get() == 1 {
                 ReturnCode::SUCCESS
@@ -200,12 +205,26 @@ impl Radio {
                 ReturnCode::FAIL
             };
 
+            unsafe {
+                let parsed_type = BLEAdvertisementType::from_u8((PAYLOAD[0] >> 4) & 0x0f);
+
+                let pdu = parsed_type.map(|adv_type| BLEPduType::from_buffer(adv_type, &PAYLOAD[..]) );
+
+                if let Some(pdu) = pdu {
+                    debug!("{:?}", pdu);
+                    //debug!("Hej");
+                }
+
+                //debug!("rx Optional is present: {}", self.rx_client.get().is_some());
+                //debug!("tx Optional is present: {}", self.tx_client.get().is_some());
+                //debug!("Regs state: {:?}", regs.state.get());
+            }
+
             match regs.state.get() {
                 nrf5x::constants::RADIO_STATE_TXRU
                 | nrf5x::constants::RADIO_STATE_TXIDLE
                 | nrf5x::constants::RADIO_STATE_TXDISABLE
                 | nrf5x::constants::RADIO_STATE_TX => {
-                    self.radio_off();
                     self.tx_client
                         .get()
                         .map(|client| client.transmit_event(result));
@@ -214,7 +233,6 @@ impl Radio {
                 | nrf5x::constants::RADIO_STATE_RXIDLE
                 | nrf5x::constants::RADIO_STATE_RXDISABLE
                 | nrf5x::constants::RADIO_STATE_RX => {
-                    self.radio_off();
                     unsafe {
                         self.rx_client.get().map(|client| {
                             client.receive_event(&mut PAYLOAD, PAYLOAD[1] + 1, result)
diff --git a/chips/nrf5x/src/ble_advertising_driver.rs b/chips/nrf5x/src/ble_advertising_driver.rs
index ceeec71a..abb8c1cb 100644
--- a/chips/nrf5x/src/ble_advertising_driver.rs
+++ b/chips/nrf5x/src/ble_advertising_driver.rs
@@ -199,6 +199,7 @@ use ble_advertising_hil;
 use ble_advertising_hil::RadioChannel;
 use core::cell::Cell;
 use core::cmp;
+use core::fmt;
 use kernel;
 use kernel::hil::time::Frequency;
 use kernel::returncode::ReturnCode;
@@ -271,6 +272,63 @@ enum BLEGapType {
     ManufacturerSpecificData = 0xFF,
 }
 
+pub struct DeviceAddress([u8; 6]);
+
+impl DeviceAddress {
+    fn new(slice: &[u8]) -> DeviceAddress {
+        let mut address : [u8; 6] = Default::default();
+        address.copy_from_slice(slice);
+        DeviceAddress(address)
+    }
+}
+
+
+impl fmt::Debug for DeviceAddress {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        write!(f, "{:x}:{:x}:{:x}:{:x}:{:x}:{:x}",
+               self.0[0], self.0[1], self.0[2],
+               self.0[3], self.0[4], self.0[5])
+    }
+}
+
+#[allow(unused)]
+struct LLData {
+    aa: [u8; 4],
+    crc_init: [u8; 3],
+    win_size: u8,
+    win_offset: u16,
+    interval: u16,
+    latency: u16,
+    timeout: u16,
+    chm: [u8; 5],
+    hop_and_sca: u8 // hops 5 bits, sca 3 bits
+}
+
+#[derive(Debug)]
+pub enum BLEPduType<'a> {
+    ConnectUndirected(DeviceAddress, &'a [u8]),
+    ConnectDirected(DeviceAddress, DeviceAddress),
+    NonConnectDirected(DeviceAddress, &'a [u8]),
+    ScanUndirected(DeviceAddress, &'a [u8]),
+    ScanRequest(DeviceAddress, DeviceAddress),
+    ScanResponse(DeviceAddress, &'a [u8]),
+    ConnectRequest(DeviceAddress, DeviceAddress, &'a [u8])
+}
+
+impl <'a> BLEPduType<'a> {
+    pub fn from_buffer(pdu_type: BLEAdvertisementType, buf: &[u8]) -> BLEPduType {
+        match pdu_type {
+            BLEAdvertisementType::ConnectUndirected => BLEPduType::ConnectUndirected(DeviceAddress::new(&buf[2..8]), &buf[8..]),
+            BLEAdvertisementType::ConnectDirected => BLEPduType::ConnectDirected(DeviceAddress::new(&buf[2..8]), DeviceAddress::new(&buf[8..14])),
+            BLEAdvertisementType::NonConnectUndirected => BLEPduType::NonConnectDirected(DeviceAddress::new(&buf[2..8]), &buf[8..]),
+            BLEAdvertisementType::ScanUndirected => BLEPduType::ScanUndirected(DeviceAddress::new(&buf[2..8]), &buf[8..]),
+            BLEAdvertisementType::ScanRequest => BLEPduType::ScanRequest(DeviceAddress::new(&buf[2..8]), DeviceAddress::new(&buf[8..14])),
+            BLEAdvertisementType::ScanResponse => BLEPduType::ScanResponse(DeviceAddress::new(&buf[2..8]), &buf[8..]),
+            BLEAdvertisementType::ConnectRequest => BLEPduType::ConnectRequest(DeviceAddress::new(&buf[2..8]), DeviceAddress::new(&buf[8..14]), &buf[14..]),
+        }
+    }
+}
+
 // ConnectUndirected (ADV_IND): connectable undirected advertising event
 // BLUETOOTH SPECIFICATION Version 4.2 [Vol 6, Part B], section 2.3.1.1
 //
@@ -330,7 +388,8 @@ enum BLEGapType {
 //
 #[allow(unused)]
 #[repr(u8)]
-enum BLEAdvertisementType {
+#[derive(Debug)]
+pub enum BLEAdvertisementType {
     ConnectUndirected = 0x00,
     ConnectDirected = 0x01,
     NonConnectUndirected = 0x02,
@@ -340,6 +399,21 @@ enum BLEAdvertisementType {
     ScanUndirected = 0x06,
 }
 
+impl BLEAdvertisementType {
+    pub fn from_u8(pdu_type: u8) -> Option<BLEAdvertisementType> {
+        match pdu_type {
+            0x00 => Some(BLEAdvertisementType::ConnectUndirected),
+            0x01 => Some(BLEAdvertisementType::ConnectDirected),
+            0x02 => Some(BLEAdvertisementType::NonConnectUndirected),
+            0x03 => Some(BLEAdvertisementType::ScanRequest),
+            0x04 => Some(BLEAdvertisementType::ScanResponse),
+            0x05 => Some(BLEAdvertisementType::ConnectRequest),
+            0x06 => Some(BLEAdvertisementType::ScanUndirected),
+            _ => None
+        }
+    }
+}
+
 const PACKET_START: usize = 0;
 const PACKET_HDR_PDU: usize = 0;
 const PACKET_HDR_LEN: usize = 1;
@@ -670,6 +744,7 @@ where
     // recently performed an operation.
     fn fired(&self) {
         let now = self.alarm.now();
+        //debug!("Timer fired!");
 
         self.app.each(|app| {
             if let Expiration::Abs(exp) = app.alarm_data.expiration {
@@ -724,6 +799,9 @@ where
     A: kernel::hil::time::Alarm + 'a,
 {
     fn receive_event(&self, buf: &'static mut [u8], len: u8, result: ReturnCode) {
+
+        //debug!("{:#?}", buf);
+
         if let Some(appid) = self.receiving_app.get() {
             let _ = self.app.enter(appid, |app, _| {
                 // Validate the received data, because ordinary BLE packets can be bigger than 39
@@ -749,11 +827,11 @@ where
                     false
                 };
 
-                if notify_userland {
+/*                if notify_userland {
                     app.scan_callback.map(|mut cb| {
                         cb.schedule(usize::from(result), len as usize, 0);
                     });
-                }
+                }*/
 
                 match app.process_status {
                     Some(BLEState::Scanning(RadioChannel::AdvertisingChannel37)) => {
diff --git a/kernel/src/debug.rs b/kernel/src/debug.rs
index fe6db611..c3616888 100644
--- a/kernel/src/debug.rs
+++ b/kernel/src/debug.rs
@@ -75,7 +75,7 @@ macro_rules! debug_gpio {
 // debug! and debug_verbose! support
 
 pub const APPID_IDX: usize = 255;
-const BUF_SIZE: usize = 1024;
+const BUF_SIZE: usize = 8182;
 
 pub struct DebugWriter {
     driver: Option<&'static Driver>,
diff --git a/userland/examples/ble_passive_scanning/main.c b/userland/examples/ble_passive_scanning/main.c
index b076e1ed..8c4537ee 100644
--- a/userland/examples/ble_passive_scanning/main.c
+++ b/userland/examples/ble_passive_scanning/main.c
@@ -30,6 +30,7 @@ struct Vector scan_list = {.data = (unsigned char (*)[BUF_SIZE])data,
 
 static void callback(int result, int len, __attribute__((unused)) int unused2,
                      __attribute__((unused)) void *ud) {
+  printf("CALLBACK\n");
   if (result == TOCK_SUCCESS) {
     if (!listFull() && validAdType(scan[0]) && !isDetected()) {
       memcpy(scan_list.data[scan_list.size], scan, len);
